
# 1. 定义行为模式

正常的小车的行为模式和错误小车的行为模式；

思路：我们将模型的输出分为两类——预测值和分类概率分布，两者同时决定设备身份验证结果

预测值：我们每隔k时刻取${t_{1},t_{2},t_{3},...,t_{n}}$时刻的小车数据时空位置和电量。我们用$t_{1},t_{2},t_{3},...,t_{n-1}$时刻的数据进行训练，预测第$t_{n}$时刻的数据

分类概率：我们将五种状态进行one-hot编码：

* 运行 10000
* 待料 01000
* 封存 00100
* 检修 00010
* 没电 00001 
  
要求:

正样本状态是运行状态和待料状态(等待6秒)

负样本产生三种错误状态: 封存 、检修 、没电三种错误状态.同时三种错误状态对应不同的错误数据，封存状态数据是不同时刻位置状态和初始状态相同，检修状态是位移到某个随即时刻后不再移动，有电量，没电状态是某个时刻后不再移动，电量为0.

# 2. 生成数据用于迁移学习 

**2.1. [Dataset.py](Dataset.py)**

由于无人机数据新增z轴坐标，因此我们生成的数据应该是四个维度：`X, Y, Z, Power`，为此我们需要将生成数据的函数进行重写：
```
generate_car_data: 新增z轴始终为0
generate_forklift_data: 新增z轴始终为0
generate_uav_data：新增z轴不为0
```

同时[Model](Model.py) 也需要改变输入`input_size=4`

**2.2 [route.py](route.py)**

同时为了叉车和无人机的数据，我们为其设计了新的路线:

* 无人车的路线代号1-3: ![无人车路线](results/car_route.png)
* 智能叉车路线代号4-8: ![智能叉车路线](results/forklift_route.png)
* 无人机的路线代号9-12: ![无人机路线](results/uav_route.png)

# 3. 代码介绍

## 3.1 [Dataset.py](Dataset.py)

本文档解释了如何生成不同类型车辆（如小车、叉车、无人机）的模拟数据，并展示它们在不同状态下的操作情况。代码能够生成用于训练和测试的数据集，并输出不同状态的样本。


### 3.1.1. `generate_car_data()`

该函数生成小车的模拟数据，包括“运行”、“待料”、“封存”、“检修”和“没电”等多种操作状态。每辆车的轨迹基于随机选择的路线进行计算，具体步骤如下：

1. **数据初始化**：为每辆小车初始化位置、速度、状态和电量等参数。
2. **状态生成**：
   - 正样本（运行或待料状态）：
     - **运行状态**：小车根据恒定速度移动，电量随位移消耗逐渐减少。
     - **待料状态**：小车在随机时间段内停止移动，等待装车后继续行驶。
   - 负样本（封存、检修、没电状态）：
     - **封存状态**：小车停止移动，电量保持不变。
     - **检修状态**：小车在某一随机时刻停止运行，并保持在停止位置。
     - **没电状态**：小车在电量耗尽时停止运行，电量逐渐归零。

3. **返回结果**：函数返回包含车辆位置、电量等信息的数据集，以及车辆设备指纹等信息。

### 3.1.2. `generate_forklift_data()` 和 `generate_uav_data()`

与 `generate_car_data()` 类似，`generate_forklift_data()` 和 `generate_uav_data()` 分别用于生成叉车和无人机的模拟数据，流程基本相同，但路线和速度的计算有所不同。

## 3.2 [device.py](device.py)

本项目的主要目标是生成包含静态和动态信息的无人车数据，并基于设备指纹生成公私钥对。以下是项目的详细介绍：

主要功能

* 生成设备指纹
* 生成RSA密钥对
* 生成无人车数据
* 获取特定属性
* 修改特定属性

属性分类：

静态属性、动态属性、设备指纹、公私钥

* 静态属性：
  
| 属性名            | 类型   | 描述                          |
| ----------------- | ------ | ----------------------------- |
| `id`              | 字符串 | 唯一标识符，由UUID生成         |
| `name`            | 字符串 | 无人车的名称                   |
| `manufacturer`    | 字符串 | 制造商名称                     |
| `device_type`     | 字符串 | 设备类型，例如：`car`          |
| `warranty_period` | 整数   | 保修期，以月为单位             |
| `os`              | 字符串 | 操作系统                       |
| `os_version`      | 字符串 | 操作系统版本                   |
| `machine`         | 字符串 | 机器类型（硬件信息）           |
| `processor`       | 字符串 | 处理器信息                     |
| `hostname`        | 字符串 | 主机名                         |
| `ip_address`      | 字符串 | IP 地址                        |
| `mac_address`     | 字符串 | MAC 地址                       |

示例：

```python
{
    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "name": "car_123",
    "manufacturer": "manufacturer_456",
    "device_type": "car",
    "warranty_period": 12,
    "os": "Linux",
    "os_version": "5.4.0-74-generic",
    "machine": "x86_64",
    "processor": "Intel(R) Core(TM) i7-8650U CPU @ 1.90GHz",
    "hostname": "car-hostname",
    "ip_address": "192.168.1.10",
    "mac_address": "00:1A:2B:3C:4D:5E"
}
```

* 动态属性
  
| 属性名       | 类型             | 描述                          |
| ------------ | ---------------- | ----------------------------- |
| `position`   | 元组 (浮点数, 浮点数) | 无人车的当前位置               |
| `speed`      | 浮点数           | 无人车的速度                   |
| `power`      | 整数             | 无人车的电量                   |
| `route`      | 整数             | 无人车当前的路线编号           |
| `permissions`| 列表（字符串）   | 无人车的权限，例如：`['admin', 'operator']` |
| `frequence`  | 整数             | 无人车数据更新的频率，以秒为单位 |

示例：

```python
{
    "position": [52.3765, 4.8945],
    "speed": 8.5,
    "power": 85,
    "route": 2,
    "permissions": ["admin", "viewer"],
    "frequence": 10
}
```

全部属性完整示例：

```python
{
    "static_info": {
        "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
        "name": "car_123",
        "manufacturer": "manufacturer_456",
        "device_type": "car",
        "warranty_period": 12,
        "os": "Linux",
        "os_version": "5.4.0-74-generic",
        "machine": "x86_64",
        "processor": "Intel(R) Core(TM) i7-8650U CPU @ 1.90GHz",
        "hostname": "car-hostname",
        "ip_address": "192.168.1.10",
        "mac_address": "00:1A:2B:3C:4D:5E"
    },
    "dynamic_info": {
        "position": [52.3765, 4.8945],
        "speed": 8.5,
        "power": 85,
        "route": 2,
        "permissions": ["admin", "viewer"],
        "frequence": 10
    },
    "fingerprint": "a9b7ba70783b617e9998dc4dd82eb3c5",
    "private_key": "-----BEGIN PRIVATE KEY-----\nMIIE... (省略) ...QAB\n-----END PRIVATE KEY-----",
    "public_key": "-----BEGIN PUBLIC KEY-----\nMIIBIj... (省略) ...wIDAQAB\n-----END PUBLIC KEY-----"
}

```

## 3.3 [train_test_model.py](train_test_model.py)

利用无人车数据对初始化的LSTM进行训练和预测


## 3.4 [devicefinger_test.py](./devicefinger_test.py)

和设备指纹进行对比

## 3.5 [cloud_edge_client.py](cloud_edge_client.py)

该项目基于LSTM模型实现了云端、边端和小车设备的协同工作流程。通过不同的进程分别模拟云端、边端和小车的行为，演示了如何在分布式环境中进行模型训练、微调、测试及设备验证。

该系统包含三个主要的进程：

1. **云端进程**：负责模型的初始化、训练以及微调，并与边端设备进行数据交换。
2. **边端进程**：接收云端的模型数据，使用接收到的小车数据进行模型测试，并将结果传回云端。
3. **小车进程**：生成测试数据并将其发送给边端设备进行模型测试。

系统通过Socket通信实现各进程之间的数据传输，模拟了云端和边端之间的协同工作流程。

**云端-边端-小车 三进程通信流程图**

```mermaid
graph TD
    subgraph 云端进程
    A1[初始化LSTM模型] --> A2[训练数据]
    A2 --> A3[训练模型]
    A3 --> A4[等待边端连接]
    A4 --> A5[发送模型到边端]
    A5 --> A6[接收边端的测试数据]
    A6 --> A7[微调模型并保存]
    A7 --> A8[继续测试]
    end

    subgraph 边端进程
    B1[连接云端] --> B2[接收LSTM模型]
    B2 --> B3[等待小车发送测试数据]
    B3[等待小车发送测试数据] --> B4[接收测试数据]
    B4 --> B5[使用模型进行测试]
    B5 --> B6[将测试数据发送回云端]
    end

    subgraph 小车进程
    C1[生成测试数据] --> C2[等待连接边端]
    C2 --> C3[发送测试数据到边端]
    end

    B1 -->|连接成功| A4
    A5 -->|开始发送| B2
    C2 -->|连接成功| B3
    B6 -->|发送测试结果| A6
    C3 -->|发送测试数据| B4
```

## 3.6 [transfer_learning.py](transfer_learning.py)

本项目通过LSTM模型进行不同类型设备（如叉车和无人机）的智能控制模型训练、微调和测试。系统采用迁移学习的方式，首先训练小车模型，然后将其用于叉车和无人机，并通过微调进行性能优化。

项目包含以下主要步骤：

1. 生成叉车和无人机的数据集：训练集、测试集、微调数据集
2. 重新训练叉车和无人机的模型进行测试
3. 直接使用小车模型测试叉车和无人机
4. 微调小车模型用于叉车和无人机进行测试

## 3.7 [package](package/pred_classs.py)

时间:2024.11.6

当来一个输入是0时，表明是身份真实的设备，然后给它生成真实设备的属性，并通过封装的模型，输出验证结果0或1；当来一个输入是1时，表明是身份不真实的设备，然后给它生成不真实设备的属性，并通过封装的模型，输出验证结果0或1。
